const d3 = require('d3');
const kebabCase = require('lodash.kebabcase');
const Chart = {
  htmlTableToJson(chart) {
    let data = []; // debugger;
    let headers = Array.from(chart.firstChild.querySelectorAll('th')).map(th => th.innerHTML);
    // let headers = ['label', 'value'];
    let cells = Array.from(chart.firstChild.querySelectorAll('td')).map(td => td.innerHTML);
    let numRows = cells.length / headers.length; // 6
    let numCols = headers.length; // 2

    let dividedCells = [];
    for (let i = 0; i < cells.length; i += numCols) {
      let subArray = cells.slice(i, i + numCols);
      dividedCells.push(subArray);
    }

    dividedCells.map((container, idx) => {
      let dataContainer = new Object();
      container.forEach((cell, idx) => {
        dataContainer[headers[idx]] = cell;
      });
      data.push(dataContainer);
    });
    return data;
  },
  htmlTableToCsv(chart) {
    let data = []; // debugger;
    let headers = Array.from(chart.firstChild.querySelectorAll('th')).map(th => th.innerHTML);
    // let headers = ['label', 'value'];
    let cells = Array.from(chart.firstChild.querySelectorAll('td')).map(td => td.innerHTML);
    let numRows = cells.length / headers.length; // 6
    let numCols = headers.length; // 2

    let dividedCells = [];
    dividedCells += headers.join(',') + '\n';
    for (let i = 0; i < cells.length; i += numCols) {
      let subArray = cells.slice(i, i + numCols);
      dividedCells += subArray.join(',') + '\n';
    }
    return dividedCells;
  },
  gatherTables() {
    let activeTables = document.querySelectorAll('.d3-chart');
    activeTables.forEach(chart => {
      if (chart.classList.contains('d3-pie-chart')) {
        this.createPieChart(chart);
      } else if (chart.classList.contains('d3-bar-chart')) {
        this.createBarChart(chart);
      }
    });
  },
  createBarChart(chart) {
    // https://observablehq.com/@d3/stacked-bar-chart/2
    let csvData = this.htmlTableToCsv(chart);

    let data = Object.assign(d3.csvParse(csvData, d3.autoType));

    // List of subgroups = header of the csv files
    let subgroups = data.columns.slice(1);
    // create the stacks -- column 1 is x axis, row 1 is stacked content
    let stackedData = d3.stack().keys(subgroups)(data);

    let headers = data.columns;

    // List of groups = species here = value of the first column called group -> I show them on the X axis
    let groups = d3.map(data, function (data) {
      return data[headers[0]]; //requires the x axis to be the first column
    });

    // color palette generated by number of subgroups
    const color = key => {
      const scale = d3.scaleOrdinal(d3.schemeTableau10).domain(subgroups);

      return scale(key);
    };

    this.appendChartContainer(chart);

    let chartAttrs = this.getBarChartAttributes();

    // create svg and append under the table

    let svg = d3
      .select(`#${chart.id}-chart`)
      .append('svg')
      .attr('width', chartAttrs.width + chartAttrs.margin.left + chartAttrs.margin.right)
      .attr('height', chartAttrs.height + chartAttrs.margin.top + chartAttrs.margin.bottom)
      .attr('viewBox', '-20 180 900 260')
      .attr('class', 'barchart-svg')
      .append('g')
      .attr('transform', 'translate(' + chartAttrs.margin.left + ',' + chartAttrs.margin.top + ')');

    // Prepare the scales for positional and color encodings.
    // Add x axis

    const x = d3
      .scaleBand()
      .domain(groups)
      .range([0, chartAttrs.width])
      .padding([0.2]);
    svg
      .append('g')
      .attr('transform', 'translate(0,' + chartAttrs.height + ')')
      .call(d3.axisBottom(x).tickSizeOuter(0));

    // add y axis
    // assign column of stacked values (header[1]) converted to series 'data' attr of series to get max domain, currrently hardcoded to

    const y = d3
      .scaleLinear()
      .domain([
        0,
        d3.max(stackedData, d => {
          // get yMax for appropriate ticks
          return d3.max(d, d => d[1]);
        })
      ])
      .range([chartAttrs.height, 0]);
    svg.append('g').call(d3.axisLeft(y));

    svg.append('g').call(d3.axisLeft(y));

    svg
      .append('g')
      .selectAll('g')
      // Enter in the stack data = loop key per key = group per group
      .data(stackedData)
      .enter()
      .append('g')
      .attr('data-item', d => d.index)
      .attr('fill', d => color(d.key))
      .on('mouseover', (e, d) => {
        highlightPaths(e.target);
        highlightLegendButton(d.key);
      })
      .on('mouseout', () => {
        removeLegendButtonHighlight();
        removePathHighlight();
      })
      .selectAll('rect')
      // enter a second time = loop subgroup per subgroup to add all rectangles
      .data(d => d)
      .enter()
      .append('rect')
      .attr('data-item-group', d => d.data[headers[0]])
      .attr('data-item-type', d => console.log("fdsfds", d))
      .attr('x', function (d) {
        return x(d.data[headers[0]]);
      })
      .attr('y', function (d) {
        return y(d[1]);
      })
      .attr('height', function (d) {
        return y(d[0]) - y(d[1]);
      })
      .attr('width', x.bandwidth());

    // append legend container
    let legendContainer = this.appendLegendContainer(chart);

    subgroups.forEach(group => {
      let buttonEl = document.createElement('button');
      buttonEl.setAttribute('id', `${kebabCase(group)}`);
      buttonEl.setAttribute('class', 'legend-button');
      buttonEl.innerText = group;
      buttonEl.style.backgroundColor = color(group)
      legendContainer.insertAdjacentElement('beforeend', buttonEl);
    });

    const highlightPaths = chartData => {
      d3.select(`#${chart.id}-chart`)
        .selectAll('rect')
        .each(function (d, i) {
          if (this !== chartData) {
            d3.select(this)
              .transition()
              .attr('opacity', '0.25');
          }
        });
    };

    const removePathHighlight = () => {
      d3.select(`#${chart.id}-chart`)
        .selectAll('rect')
        .each(function () {
          d3.select(this)
            .transition()
            .attr('opacity', '1');
        });
    };

    // Highlight legend button on path mouseover
    let legendButtons = document.getElementById(`${chart.id}-legend`).children;
    legendButtons = Array.prototype.slice.call(legendButtons);

    const highlightLegendButton = chartData => {
      legendButtons.forEach(button => {
        if (button.id !== kebabCase(chartData)) {
          button.style.opacity = '0.25';
        }
      });
    };

    const removeLegendButtonHighlight = () => {
      legendButtons.forEach(button => {
        button.style.opacity = '1';
      });
    };

    // Highlight path on legend mouseover
    legendButtons.forEach(button => {
      button.addEventListener('mouseover', e => {
        const buttonData = e.target.id;
        highlightLegendButton(buttonData);
      });

      button.addEventListener('mouseout', () => {
        removeLegendButtonHighlight();
      });
    });
  },
  getBarChartAttributes() {
    const defaultWidth = 800;
    const defaultHeight = 600;

    const margin = {
      top: 10,
      right: 10,
      bottom: 20,
      left: 40
    };

    return {
      margin,
      width: defaultWidth,
      height: defaultHeight
    };
  },
  createPieChart(chart) {
    this.appendChartContainer(chart);

    let csvData = this.htmlTableToCsv(chart);

    let data = Object.assign(d3.csvParse(csvData, d3.autoType));

    let headers = data.columns;

    const color = d3
      .scaleOrdinal()
      .domain(headers)
      .range(d3.schemeTableau10);

    // begin vars
    const chartAttrs = this.getPieChartAttributes();

    // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
    const radius = Math.min(chartAttrs.width, chartAttrs.height) / 2 - chartAttrs.margin;

    // Compute the position of each group on the pie
    const pie = d3.pie().value(d => {
      // console.log(d[headers[0]])
      return d[headers[1]];
    })(data);

    // shape helper to build arcs:
    const arc = d3
      .arc()
      .innerRadius(chartAttrs.innerRadius)
      .outerRadius(chartAttrs.outerRadius);

    const arcLabel = d3
      .arc()
      .innerRadius(chartAttrs.innerRadius)
      .outerRadius(chartAttrs.labelRadius);

    const midAngle = d => {
      return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };

    // end vars

    // create the svg
    let svg = d3
      .select(`#${chart.id}-chart`)
      .append('svg')
      .attr('width', chartAttrs.width)
      .attr('height', chartAttrs.height)
      .attr('viewBox', [-chartAttrs.width / 2, -chartAttrs.height / 2, chartAttrs.width, chartAttrs.height]);

    svg
      .append('g')
      .selectAll('path')
      .data(pie)
      .join('path')
      .attr('fill', (d, i) => {
        console.log(i)
        return color(i);
      })
      .attr('d', arc)
      .attr('title', d => d[headers[0]])
      .attr('data-item', d => d.index)
      .on('mouseover', (e, d) => {
        addAllHighlights(d);
      })
      .on('mouseout', () => {
        removeAllHighlights();
      });

    svg
      .append('g')
      .selectAll('polyline')
      .data(pie)
      .join('polyline')
      .attr('stroke', '#aaa')
      .attr('opacity', '.3')
      .attr('stroke-width', '1px')
      .attr('fill', 'none')
      .attr('data-item', d => d.index)
      .attr('data-title', d => kebabCase(d.data[Object.keys(d.data)[0]]))
      .attr('class', `pie-legend-item--${chart.id}`)
      .attr('points', d => {
        const pos = arcLabel.centroid(d);
        const pieCenter = arc.centroid(d);
        pos[0] = chartAttrs.labelRadius * 1.3 * (midAngle(d) < Math.PI ? 1 : -1);
        // return [pieCenter, arcLabel.centroid(d), pos];
        return [arcLabel.centroid(d), pos];
      })
      .on('mouseover', (e, d) => {
        addAllHighlights(d);
      })
      .on('mouseout', () => {
        removeAllHighlights();
      });

    svg
      .append('g')
      .attr('font-family', 'sans-serif')
      .attr('font-size', 14)
      .attr('fill', 'black')
      .selectAll('text')
      .data(pie)
      .join('text')
      .attr('class', `pie-legend-item--${chart.id}`)
      .attr('data-item', d => d.index)
      .attr('data-title', d => kebabCase(d.data[Object.keys(d.data)[0]]))
      .attr('transform', d => {
        const pos = arcLabel.centroid(d);
        pos[0] = chartAttrs.labelRadius * 1 * (midAngle(d) < Math.PI ? 0.89 : -1.3);
        return `translate(${pos})`;
      })
      .attr('text-anchor', d => (midAngle(d) < Math.PI ? 'start' : 'start'))
      .attr('dy', '-5')
      .text(d => {
        return d.data[headers[0]];
      })
      .on('mouseover', (e, d) => {
        addAllHighlights(d);
      })
      .on('mouseout', () => {
        removeAllHighlights();
      });

    svg
      .append('g')
      .attr('font-family', 'sans-serif')
      .attr('font-size', 17)
      .attr('text-anchor', 'middle')
      .attr('fill', '#000')
      .selectAll('text')
      .data(pie)
      .join('text')
      .attr('class', `pie-legend-item--${chart.id}`)
      .attr('data-item', d => d.index)
      .attr('data-title', d => kebabCase(d.data[Object.keys(d.data)[0]]))
      .attr('transform', d => `translate(${arcLabel.centroid(d)})`)
      // .attr('transform', d => {
      //   const pieCenter = arc.centroid(d);
      //   return `translate(${pieCenter})`;
      // })
      .text(d => {
        return d[headers[1]];
      });

    // Value inside slice
    svg
      .append('g')
      .selectAll('polyline')
      .data(pie)
      .enter()
      .append('text')
      .text(d => d.data.number_of_cases)
      .attr('transform', d => `translate(${arcLabel.centroid(d)})`)
      .attr('class', `pie-legend-item--${chart.id}`)
      .attr('data-item', d => d.index)
      .attr('data-title', d => kebabCase(d.data[Object.keys(d.data)[0]]))
      .style('font-size', 18)
      .on('mouseover', (e, d) => {
        addAllHighlights(d);
      })
      .on('mouseout', () => {
        removeAllHighlights();
      });

    // Percentage
    svg
      .append('g')
      .attr('font-family', 'sans-serif')
      .attr('font-size', 13)
      .attr('fill', 'gray')
      .selectAll('text')
      .data(pie)
      .join('text')
      .attr('transform', d => {
        const pos = arcLabel.centroid(d);
        pos[0] = chartAttrs.labelRadius * 1 * (midAngle(d) < Math.PI ? 1.3 : -1.175);
        return `translate(${pos})`;
      })
      .attr('text-anchor', d => (arc(d) < Math.PI ? 'start' : 'end'))
      .text(d => `${Math.round(((d.endAngle - d.startAngle) / (2 * Math.PI)) * 100 * 10) / 10}%`)
      .attr('class', `pie-legend-item--${chart.id}`)
      .attr('data-item', d => d.index)
      .attr('data-title', d => kebabCase(d.data[Object.keys(d.data)[0]]))
      .attr('dy', '15')
      .on('mouseover', (e, d) => {
        addAllHighlights(d);
      })
      .on('mouseout', () => {
        removeAllHighlights();
      });

    // Circle dot
    svg
      .selectAll('marker')
      .data(pie)
      .enter()
      .append('circle')
      .attr('stroke', '#aaa')
      .style('fill', '#aaa')
      .attr('data-item', d => d.index)
      .attr('r', 2)
      .attr('transform', d => {
        const pos = arcLabel.centroid(d);
        return `translate(${pos})`;
      });

    const legendItems = document.getElementsByClassName(`pie-legend-item--${chart.id}`);
    const legendItemsArray = Array.prototype.slice.call(legendItems);

    const highlightLegendItems = chartData => {
      legendItemsArray.forEach(item => {
        if (parseInt(item.getAttribute('data-item')) !== chartData) {
          item.style.opacity = '0.25';
        }
      });
    };

    const highlightPaths = chartData => {
      d3.select(`#${chart.id}-chart`)
        .selectAll('path')
        .each(function (d, i) {
          if (d.index !== chartData) {
            d3.select(this)
              .transition()
              .attr('opacity', '0.25');
          }
        });
    };

    const removePathHighlight = () => {
      d3.select(`#${chart.id}-chart`)
        .selectAll('path')
        .each(function (d, i) {
          d3.select(this)
            .transition()
            .attr('opacity', '1');
        });
    };

    const removeLegendHighlight = () => {
      legendItemsArray.forEach(item => {
        item.style.opacity = '1';
      });
    };

    // generate legend
    const legendKeys = data.map(d => d[Object.keys(d)[0]]);

    let legendContainer = this.appendLegendContainer(chart);

    legendKeys.forEach((key, i) => {
      let buttonEl = document.createElement('button');
      buttonEl.setAttribute('id', `${kebabCase(key)}-button`);
      buttonEl.setAttribute('class', 'legend-button');
      buttonEl.innerText = key;
      buttonEl.setAttribute('data-item', kebabCase(key));
      buttonEl.style.backgroundColor = color(i);
      legendContainer.insertAdjacentElement('beforeend', buttonEl);
    });

    // Highlight legend button on path mouseover
    let legendButtons = document.getElementById(`${chart.id}-legend`).children;
    legendButtons = Array.prototype.slice.call(legendButtons);

    const highlightLegendButton = chartData => {
      legendButtons.forEach(button => {
        if (button.getAttribute('data-item') !== chartData) {
          button.style.opacity = '0.25';
        }
      });
    };

    const removeLegendButtonHighlight = () => {
      legendButtons.forEach(button => {
        button.style.opacity = '1';
      });
    };

    // Highlight path on legend mouseover
    legendButtons.forEach(button => {
      button.addEventListener('mouseover', e => {
        const buttonData = e.target.getAttribute('data-item');
        highlightLegendButton(buttonData);

        d3.select(`#${chart.id}-chart`)
          .selectAll('path')
          .each(function (d, i) {
            if (kebabCase(d.data[Object.keys(d.data)[0]]) !== buttonData) {
              d3.select(this)
                .transition()
                .attr('opacity', '0.25');
            }
          });

        legendItemsArray.forEach(item => {
          if (item.getAttribute('data-title') !== buttonData) {
            item.style.opacity = '0.25';
          }
        });
      });

      button.addEventListener('mouseout', () => {
        removeLegendButtonHighlight();
        removeLegendHighlight();
        d3.select(`#${chart.id}-chart`)
          .selectAll('path')
          .each(function (d, i) {
            d3.select(this)
              .transition()
              .attr('opacity', '1');
          });
      });
    });

    const addAllHighlights = chartData => {
      highlightLegendItems(chartData.index);
      highlightPaths(chartData.index);
      highlightLegendButton(kebabCase(chartData.data[Object.keys(chartData.data)[0]]));
    };

    const removeAllHighlights = () => {
      removeLegendHighlight();
      removePathHighlight();
      removeLegendButtonHighlight();
    };
  },
  /* pie chart methods start */
  getPieChartAttributes() {
    return {
      width: 600,
      height: 450,
      innerRadius: 0,
      outerRadius: 200,
      labelRadius: 290
    };
  },
  appendLegendContainer(chart) {
    let chartLocation = document.getElementById(`${chart.id}-chart`);
    let legendContainer = document.createElement('div');
    legendContainer.setAttribute('id', `${chart.id}-legend`);
    legendContainer.setAttribute('class', 'legend');
    chartLocation.insertAdjacentElement('beforeend', legendContainer);
    return legendContainer;
  },
  appendChartContainer(chart) {
    let chartLocation = document.getElementById(chart.id);

    let visualizationContainer = document.createElement('div');
    visualizationContainer.setAttribute('id', `${chart.id}-chart`);
    visualizationContainer.setAttribute('class', 'visualization');
    chartLocation.insertAdjacentElement('beforebegin', visualizationContainer);
  },
  init() {
    this.gatherTables();
  }
};

module.exports = Chart;
